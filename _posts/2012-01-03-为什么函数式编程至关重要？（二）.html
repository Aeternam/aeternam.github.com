---           
layout: post
title: 为什么函数式编程至关重要？（二）
date: 2012-01-03 08:40:00 UTC
comments: false
categories: 函数式编程
---

<h1 style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 16px; font-style: normal; font-variant: normal; letter-spacing: normal; line-height: 22px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">

5 人工智能中的例子</h1>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
我们已经指出，函数式语言威力强大主要是因为它们提供了两种新的黏合剂：高阶函数和惰性求值。在本节中，我们将讨论人工智能中一个大一点的实例，并演示如何使用这两种黏合剂来十分简单地编写它。<br />
<br />
我们选取的实例是alpha-beta“启发式搜索”，一个用于估计游戏者所处形势好坏的算法。该算法预测游戏局势的可能发展，但会避免对无意义局势的进一步探究。<br />
<br />
令游戏局势使用“position”类型的对象来表示。这个类型依据游戏的不同而不同，我们不对此作任何假定。必然有一种方法可以知晓对某一个局势能够采取的行动：假定有一个函数：</div>
<pre style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 22px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; widows: 2; word-spacing: 0px;">moves: position -&gt; listof position</pre>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
该函数以一个游戏局势为参数，并返回一个可以由自变量出发，通过一步行动而形成的position的列表。以noughts and crosses游戏（tic-tac-toe）为例：</div>
<pre style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 22px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; widows: 2; word-spacing: 0px;">| |      X| |   |X|   | |
     -+-+-     -+-+- -+-+- -+-+-
moves | |   = [ | | , | | , |X| ]
     -+-+-     -+-+- -+-+- -+-+-
      | |       | |   | |   | |
       
      | |    O| |   |O|
     -+-+-   -+-+- -+-+-
moves |X| = [ |X| , |X| ]
     -+-+-   -+-+- -+-+-
      | |     | |   | |</pre>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
这个函数假定通过当前局势总是可以判定现在是哪位游戏者的回合。在noughts and crosses中，可以通过数出“0”与“X”的数目来做到这一点。在类似于象棋的游戏中，可能必须在“position”类型中显式包含这一信息。<br />
<br />
利 用函数moves，第一步是构造一棵博弈树。这棵树的结点都用局势来标记，而一个结点的子结点用从该结点一步便可到达的局势标记。也就是说，如果一个结点 标记为局势p，那么它的子结点将使用(moves p)中的局势来标记。一棵博弈树完全有可能是无穷的，如果这个游戏可以在双方都不胜的情形下永远进行下去的话。博弈树与第2节中讨论的树完全类似——每个 结点都有一个标记（它所代表的局势）与一个子结点列表。因此我们可以使用相同的数据类型来表示它们。<br />
<br />
博弈树是通过反复运用moves而构造出来的。构造从根局势开始，moves用于生成根结点处子树的标记，而后moves被用于生成子树的子树，依此类推。这一递归模式可以用一个高阶函数表示：</div>
<pre style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 22px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; widows: 2; word-spacing: 0px;">reptree f a = node a (map (reptree f) (f a))</pre>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
使用这个函数可以定义另一个函数，该函数从一个特定的局势开始生成博弈树：</div>
<pre style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 22px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; widows: 2; word-spacing: 0px;">gametree p = reptree moves p</pre>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
例如图1所示。此处使用的高阶函数(reptree）与上一节中用于构造无穷列表的函数repeat是类似的。</div>
<pre style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 22px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; widows: 2; word-spacing: 0px;">| |
         -+-+-
gametree  | |
         -+-+-
          | |
                            | |
                           -+-+-
=                           | |
                           -+-+-
                            | |
                          /  |  \
                         /   |   \
                        /    |    \
                       /     |     \
                      /      |      \
                     /       |       \
                 X| |       |X|      | |
                 -+-+-     -+-+-    -+-+-
                  | |       | |      |X|
                 -+-+-     -+-+-    -+-+-
                  | |       | |      | |
                  /|\       /|\       /\
                  ...       ...      /  \
                                    /    \
                                   /      \
                               O| |       |O|
                               -+-+-     -+-+-
                                |X|       |X|
                               -+-+-     -+-+-
                                | |       | |
                                /|\       /|\
                                ...       ...</pre>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
图1： 一棵博弈树的实例</div>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
alpha -beta算法从一个给定的局势出发，就游戏的发展将会是有利还是不利作出判断。然而，要做到这一点，它必须能够在不考虑下一步的情况下粗略地估计某一个 局势的“价值”。在后继局势不可预测时必须使用这一函数，它也可以用来对算法进行先期引导。静态估价的结果是从计算机的角度考虑的，是对该局势的前途的度 量（假设在游戏中计算机与人对抗）。结果越大，局势对计算机而言越好。结果越小，局势越糟。最简单的此类函数将会，比如说，对计算机确定胜利的局势返回+ 1，对计算机确定失败的局势返回-1，而对其它的局势返回0。在现实中，静态估价函数会衡量各种使局势“看上去不错”的因素。例如，具体的好处，以及象棋 中对中心的控制。假定有这样一个函数：</div>
<pre style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 22px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; widows: 2; word-spacing: 0px;">static: position -&gt; number</pre>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
既然一棵博弈树是一个(treeof position)，那么它就可以被函数(maptree static)转换为一个(treeof number)，该函数对树中所有的（也许是无穷多个）局势进行静态估价。此处使用了第2节中定义的函数maptree。<br />
<br />
给 出一棵静态估价树之后，其中各个局势的真值究竟是多大？特别地，对根局势应该赋予什么值？不是它的静态值，因为那只是一个粗略的猜测。一个结点被赋予的 值，必须由其子结点的真值决定。这一过程的完成，基于每个游戏者都会选择对自己最有利的行动的假定。回忆一下，高值意味着计算机的有利形势。很明显，当计 算机从任意的局势开始下一步行动时，它将选择通往真值最高的子结点的行动。类似地，对手将会选择通往真值最低的子结点的行动。假定计算机与其对手轮流行 动，那么当轮到计算机行动时，节点的真值用函数maximise计算，反之用minimise计算。</div>
<pre style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 22px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; widows: 2; word-spacing: 0px;">maximise (node n sub) = max (map minimise sub)
minimise (node n sub) = min (map maximise sub)</pre>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
此处max和min是关于列表的函数，分别返回列表中元素的最大值与最小值。上述定义是不完整的，因为它们将永远递归下去——没有给出边界情形。我们必须 定 义没有后继的结点的值（其标记）。因此静态估价用于任一游戏者胜利或者后继局势不可预测的情况下。maximise与minimise的完整定义是：</div>
<pre style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 22px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; widows: 2; word-spacing: 0px;">maximise (node n nil) = n
maximise (node n sub) = max (map minimise sub)
maximise (node n nil) = n
maximise (node n sub) = min (map minimise sub)</pre>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
在这个阶段，几乎已经可以写出一个取一个局势作为参数并返回其真值的函数了。可能是：</div>
<pre style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 22px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; widows: 2; word-spacing: 0px;">evaluate = maximise . maptree static . gametree</pre>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
这个定义有两个问题。首先，它不适用于无穷树。maximise不断地递归直到找到一个没有子树的结点——树的端点。如果没有端点那么maximise就 不会返回结果。第二个问题与第一个有关——甚至有穷的博弈树（如noughts and crosses里的那棵）事实上也可能相当大。估价整棵博弈树是不现实的——搜索必须被限定在接下去的几步之内。为此可以将树剪至一个固定的深度：</div>
<pre style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 22px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; widows: 2; word-spacing: 0px;">prune 0 (node a x) = node a nil
prune n (node a x) = node a (map (prune (n-1)) x)</pre>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
(prune n)取一棵树作为参数并“剪去”与根结点的距离超过n的所有结点。如果一棵博弈树被剪枝，那么将强制maximise对深度为n的结点执行静态估价而不是进一步递归。因此evaluate可以被定义为：</div>
<pre style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 22px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; widows: 2; word-spacing: 0px;">evaluate = maximise . maptree static . prune 5 . gametree</pre>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
这将考虑其后（比如说）5步的形势。<br />
<br />
在 此开发过程中我们已经使用了高阶函数与惰性求值。高阶函数reptree和maptree使得我们能够很容易地构造与处理博弈树。更重要的是，惰性求值确 保了我们可以使用这种方式模块化evaluate。由于博弈树具有潜在的无穷结果，在没有惰性求值的情况下，程序将永远不会终止。我们将不能写：</div>
<pre style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 22px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; widows: 2; word-spacing: 0px;">prune 5 . gametree</pre>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
而不得不将这两个函数整合成一个只构造树的前五层的函数。更糟糕的是，甚至那前五层都可能已经太大以至于无法在同一时间内存储于内存中。而在我们所写的程序中，函数</div>
<pre style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 22px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; widows: 2; word-spacing: 0px;">maptree static . prune 5 . gametree</pre>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
只是构造出了树中maximise所需的部分。由于每一部分都可以在被maximise处理完之后丢弃（被垃圾收集器回收），故完整的树从来没有存储于内 存 中。只有树的一小部分在某一段时间内被储存着。因此这个惰性程序很有效率。这一效率取决于maximise（组合链上的最后一个函数）与gametree （第一个函数）的相互作用，因此在没有惰性求值的情况下，要完成任务，只能将组合链上的所有函数整合成一个大函数。这是对模块化的强烈破坏，但也是通常的 做法。通过单独修补每个部件，我们就可以优化估价算法——这相对简单。而一个传统型程序员必须把整个程序作为一个单元来修改，这就困难多了。<br />
<br />
到目前为止，我们只是描述了简单的对最大最小值的处理（minimaxing）。但alpha-beta算法的核心是“计算maximise与minimise的值时常常不需要考虑整棵树”这一观察结果。考虑树：</div>
<pre style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 22px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; widows: 2; word-spacing: 0px;">max
       / \
      /   \
     /     \
    /       \
  min       min
  / \       / \
 /   \     /   \
1     2   0     ?</pre>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
相当奇怪地，为了估价这棵树，并不需要知道问号处的值。左子树的最小值是1，但右子树的最小值显然是一个小于或等于0的值。因此这两个最小值的最大值必然是1。这一观察结果可以被泛化并内建到maximise和minimise之中。<br />
<br />
第一步是将maximise拆分成max对一个数字列表的作用。也就是，将maximise分解为：</div>
<pre style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 22px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; widows: 2; word-spacing: 0px;">maximise = max . maximise'</pre>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
（minimise可以用类似的方法分解。由于maximise和minimise是完全对称的，故我们将只讨论maximise，而假定 minimise也照此处理。）一旦这样分解之后，maximise可以使用minimise'来发现minimise将对哪些数字求最小值，并且不再使 用minimise本身。而后便可 以在不查看某些数字的情况下便将它们丢弃。由于惰性求值的存在，如果maxmise并不会查看所有的数字列表，那么一部分列表将不会被计算，这是对计算机 时间的潜在节约。<br />
<br />
将max从maximise中“约分出来”是很简单的，得到：</div>
<pre style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 22px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; widows: 2; word-spacing: 0px;">maximise' (node n nil) = cons n nil
maximise' (node n l) = map minimise l
                     = map (min . minimise') l
                     = map min (map minimise' l)
                     = mapmin (map minimise' l)
其中 mapmin = map min</pre>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
由于minimise' 返回一个数字列表，而这个列表的最小值是minimise的结果，故(map minimise' l)返回一个数字列表的列表。Maximise'应该返回这些列表中每个列表的最小值组成的列表，但只有这个列表中的最大值才有用。我们应该定义一个 mapmin的新版本以忽略那些最小值不重要的列表。</div>
<pre style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 22px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; widows: 2; word-spacing: 0px;">mapmin (cons nums rest) =
               = cons (min nums) (omit (min nums) rest)</pre>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
函数omit传递一个“潜在的最大值”——当前所发现的最小值中最大的一个——并忽略任何比该值小的最小值。</div>
<pre style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 22px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; widows: 2; word-spacing: 0px;">omit pot nil = nil
   omit pot (cons nums rest) =
              = omit pot rest,                          当 minleq nums pot 
              = cons (min nums) (omit (min nums) rest), 否则</pre>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
minleq 以一个数字列表和一个潜在最大值为参数，如果列表的最小值小于或等于潜在最大值就返回真。要完成这一工作，它并不需要扫描整个列表！如果列表中有任意一个 元素小于或等于潜在最大值，那么列表的最小值肯定也是如此。该特别元素之后的所有元素都是无关紧要的——它们就像是上面例子中的问号一样。因此 minleq可以被定义为：</div>
<pre style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 22px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; widows: 2; word-spacing: 0px;">minleq nil pot = false
  minleq (cons num rest) port = true,            当 num&lt;=pot
                              = minleq rest pot, 否则</pre>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
如是定义了maximise'和minimise'之后，要写出一个新的估价函数就很简单了：</div>
<pre style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 22px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; widows: 2; word-spacing: 0px;">evaluate = max . maximise' . maptree static . prune 8 . gametree</pre>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
由于惰性求值的存在，使得maximise'只查看树的更小部分，这意味着整个程序会更加高效，正如prune只查看无穷树的一部分使得程序可以终止一样。对maxmise'的优化，尽管相当简单，却能对运算的速度产生戏剧性的效果。因此也使得估价函数可以看得更远。</div>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
对估价函数还可以进行其它优化。例如，刚刚描述的alpha-beta算法只有在最佳行动被最先考虑时才能够工作得最好，因为如果有一方发现了一着 妙棋，那就没必要再考虑较差的行动了，除非他证明对手至少能有一种很好的回应方式。因此可能会希望对每一个结点的子树进行排序，当计算机行动时将最高值放 在第一，而人行动时则相反。这可以使用函数：</div>
<pre style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 22px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; widows: 2; word-spacing: 0px;">highfirst (node n sub) = node n (sort higher (map lowfirst sub))
lowfirst (node n sub) = node n (sort (not.higher) (map highfirst sub))
higher (node n1 sub1)(node n2 sub2) = n1&gt;n2</pre>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
此处sort是多用途排序函数。现在估价函数定义为：</div>
<pre style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 22px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; widows: 2; word-spacing: 0px;">evaluate = max . maximise' . highfirst . maptree static . prune 8 . gametree</pre>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
也可能认为，为了限制搜索，只要考虑计算机或者对手的前三个最佳行动也已经足够了。要编写这样的程序，只需要把highfirst换成(taketree 3 . highfirst)，其中：</div>
<pre style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 22px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; widows: 2; word-spacing: 0px;">taketree n = redtree (nodett n) cons nil
  nodett n label sub = node label (take n sub)</pre>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
taketree 将树上所有的结点替换为最多有n个子结点的结点，它使用了函数(take n)，而该函数返回列表的前n个元素（如果列表比n短，那么返回的元素就少一些）。</div>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
另一种优化是对剪枝的改良。上述程序甚至在局势非常机动的情形下也会向前搜索固定的深度——有时可以决定不再搜索，例如在国际象棋中皇后受到威胁的时候。 通常可以定义某些“机动”的形势，并在遇到这样的结点之一时，不再继续搜索而停止。假定有函数“dyramic”用以确定这样的形势，那么只需要为 prune追加一个定义等式：</div>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
prune 0 (node pos sub) = node pos (map (prune 0) sub), if dynamic pos</div>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
在像这个程序一样模块化的程序里，作出这样的改动是很简单的。如前所述，这个程序的效率，关键是由链中的最后一个函数maximise与第一个函数 gametree的相互作用决定的，因此若没有惰性求值，就只能写成一个单一的程序。这样的程序难于编写，难于修改，而且，非常难于理解。</div>
<h1 style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 16px; font-style: normal; font-variant: normal; letter-spacing: normal; line-height: 22px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">

6 结论</h1>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
在本论文中，我们指出，模块化是成功的程序设计的关键。以提高生产力为目标的程序语言，必须良好地支持模块化程序设计。但是，新的作用域规则和分块编译的 技 巧是不够的——“模块化”不仅仅意味着“模块”。我们分解程序的能力直接取决于将解决方案粘在一起的能力。为了协助模块化程序设计，程序语言必须提供优良 的黏合剂。函数式程序语言提供了两种新的黏合剂——高阶函数与惰性求值。利用这些黏合剂可以将程序用新的、令人激动的方式模块化，对此我们举出了很多实 例。越小、越通用的模块越可能被广泛地重用，使后续的程序设计工作变得简单。这解释了为什么函数式程序与传统型程序比较，要小得多，也容易编写得多。它也 为函数式程序员提供了一个追求目标。如果程序的任何部分是杂乱或者复杂的，那么程序员就应当尝试将其模块化并泛化其部件。他应当期望把高阶函数和惰性求值 用作他做此事的工具。</div>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
当然，我们并不是指出高阶函数与惰性求值的力与美的第一人。例如，Turner展示了这两者如何在一个生成化学结构 的程序里大显身手［Tur81］。Abelson和Sussman强调“流”（惰性列表）是构架程序的强大工具［AS86］。Henderson使用了流 来构架函数式操作系统［P.H82］。本论文的主要贡献是，断言了模块化自身，便是函数式语言强大威力的关键。</div>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
这与当前有关惰性求值的论战也有关联。有些人认为函数式语言应当是惰性的，而其他人认为不是这样。有些人走折衷路线，只提供惰性列表以及用于构造它 们的特殊语法（例如，在Scheme中［AS86］）。本论文提供了更进一步的证据，证明惰性求值非常重要以至于不能被降为二等公民。这也许是函数式程序 员所拥有的最强大的黏合剂。人们不应当阻碍对这样一个极为重要的工具的使用。</div>
<h1 style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 16px; font-style: normal; font-variant: normal; letter-spacing: normal; line-height: 22px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">

致谢</h1>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
在牛津程序设计研究组与Phil Wadler和Richard Bird的多次交谈对本论文的写作帮助甚大。约特堡查麦兹大学的Magnus Bondesson指出了一个数值算法的早期版本中的严重错误，同时也协助了很多其他算法的开发。本论文在英国科学与工程研究评议会提供的研究基金赞助下 发表。</div>
<h1 style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 16px; font-style: normal; font-variant: normal; letter-spacing: normal; line-height: 22px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">

参考文献</h1>
<div style="-webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-attachment: initial; background-clip: initial; background-color: #f2f2f2; background-image: initial; background-origin: initial; background-position: initial initial; background-repeat: initial initial; border-bottom-width: 0px; border-color: initial; border-image: initial; border-left-width: 0px; border-right-width: 0px; border-style: initial; border-top-width: 0px; color: #333333; font-family: 'Microsoft Yahei' !important; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: initial; outline-style: initial; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: -webkit-auto; text-indent: 0px; text-transform: none; vertical-align: baseline; white-space: normal; widows: 2; word-spacing: 0px;">
[AS86] H. Abelson and G.J. Sussman. Structure and Interpretation of Computer Programs. MIT Press, Boston, 1986.<br />
[Hug89] J. Hughes. Why Functional Programming Matters. Computer Journal, 32(2), 1989.<br />
[Hug90] John Hughes. Why Functional Programming Matters. In D. Turner, editor, Research Topics in Functional Programming. Addison Wesley,<br />
1990.<br />
[MTH90] R. Milner, M. Tofte, and R. Harper. The Definition of Standard ML. MIT Press, 1990.<br />
[oD80] United States Department of Defense. The Programming Language Ada Reference Manual. Springer-Verlag, 1980.<br />
[P.H82] P.Henderson. Purely Functional Operating Systems. 1982.<br />
[Tur81] D. A. Turner. The Semantic Elegance of Applicative Languages. In Proceedings 1981 Conference on Functional Languages and Computer<br />
Architecture, Wentworth-by-the-Sea, Portsmouth, New Hampshire, 1981.<br />
[Tur85] D. A. Turner. Miranda: A non-strict language with polymorphic types. In Proceedings 1985 Conference on Functional Programming<br />
Languages and Computer Architecture, pages 1–16, Nancy, France, 1985.<br />
[Wir82] N. Wirth. Programming in Modula-II. Springer-Verlag, 1982.</div><div class="blogger-post-footer"><img width='1' height='1' src='https://blogger.googleusercontent.com/tracker/6372431252755588535-5449619315224899675?l=smilejustforfan.blogspot.com' alt='' /></div>
<p><a href="http://feedads.g.doubleclick.net/~a/R2VmE6G37Mq-jaMCT2Sdpbxrk4o/0/da"><img src="http://feedads.g.doubleclick.net/~a/R2VmE6G37Mq-jaMCT2Sdpbxrk4o/0/di" border="0" ismap="true"></img></a><br/>
<a href="http://feedads.g.doubleclick.net/~a/R2VmE6G37Mq-jaMCT2Sdpbxrk4o/1/da"><img src="http://feedads.g.doubleclick.net/~a/R2VmE6G37Mq-jaMCT2Sdpbxrk4o/1/di" border="0" ismap="true"></img></a></p><img src="http://feeds.feedburner.com/~r/RobbyLeesBolgsmilejustforfan/~4/ATGctGvXOPs" height="1" width="1"/>